package json_to_go

import (
	"bytes"
	"encoding/json"
	"fmt"
	gofmt "go/format"
	goParser "go/parser"
	"go/token"
	"math/rand"
	"regexp"
	"strconv"
	"strings"
	"time"
)

/*
	JSON-to-Go
	by Matt Holt

	https://github.com/mholt/json-to-go

	A simple utility to translate JSON into a Go type definition.
*/

var (
	floatReg      = regexp.MustCompile(`:(\s*\d*)\.0`)
	numReg        = regexp.MustCompile(`^\d+$`)
	formatReg     = regexp.MustCompile(`[^A-Za-z0-9]`)
	timeReg       = regexp.MustCompile(`\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)`)
	reLiteralUUID = regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
	caseReg1      = regexp.MustCompile(`(^|[^a-zA-Z])([a-z]+)`)
	caseReg2      = regexp.MustCompile(`([A-Z])([a-z]+)`)
	uuidReg       = regexp.MustCompile(`[xy]`)
)

func init() {
	rand.Seed(time.Now().Unix())
}

type field struct {
	value interface{}
	count int
}

type parser struct {
	tabs        int
	innerTabs   int
	parent      string
	output      string
	accumulator string
	stack       []string
	seen        map[string][]string
}

type Options struct {
	// the root structure name, default 'AutoGenerated'
	TypeName string

	Flatten bool
}

func Parse(jsonData string, options ...Options) (string, error) {
	parser := newParser()
	if len(options) == 1 {
		return parser.parse(jsonData, options[0])
	}

	return parser.parse(jsonData, Options{})
}

// create a new parser
func newParser() *parser {
	t := &parser{}
	t.seen = make(map[string][]string)
	t.stack = append(t.stack, "")
	return t
}

// clear parser inner states, then it can parse another json string
func (t *parser) reset() {
	t.tabs, t.innerTabs = 0, 0
	t.parent, t.output, t.accumulator = "", "", ""
	t.seen = make(map[string][]string)
	t.stack = append(t.stack, "")
}

// parse json data in string
func (t *parser) parse(jsonData string, option Options) (string, error) {
	data := floatReg.ReplaceAllString(jsonData, ":$1.1") // hack that forces floats to stay as floats
	var scope map[string]interface{}
	err := json.Unmarshal([]byte(data), &scope)
	if err != nil {
		return "", err
	}

	typename := option.TypeName
	flatten := option.Flatten

	if typename == "" {
		typename = "AutoGenerated"
	}

	t.append(fmt.Sprintf("\ntype %s ", format(typename)))

	t.parseScope(scope, 0, flatten)

	if flatten {
		t.output += t.accumulator
	}

	formattedOutput, err := fmtOutput(t.output)
	if err != nil {
		return t.output, nil
	}
	return formattedOutput, nil
}

func fmtOutput(s string) (string, error) {
	fs := token.NewFileSet()
	file, err := goParser.ParseFile(fs, "", "package x\n"+s, goParser.ParseComments)
	if err != nil {
		return "", err
	}

	var output []byte
	buffer := bytes.NewBuffer(output)
	err = gofmt.Node(buffer, fs, file)
	if err != nil {
		return "", err
	}
	return strings.Replace(buffer.String(), "package x\n", "", 1), nil
}

// Given two types, returns the more specific of the two
func mostSpecificPossibleGoType(typ1, typ2 string) string {
	if typ1[:5] == "float" && typ2[:3] == "int" {
		return typ1
	} else if typ1[:3] == "int" && typ2[:5] == "float" {
		return typ2
	} else {
		return "interface{}"
	}
}

func uuidv4() string {
	uuidFormat := "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
	return replaceAllStringSubmatchFunc(uuidReg, uuidFormat, func(groups []string) string {
		c := groups[0][0]
		r := rand.Intn(16)

		var v byte
		if c == 'x' {
			v = byte(r)
		} else {
			v = (byte(r) & 0x3) | 0x8
		}

		if v <= 9 {
			return fmt.Sprintf("%d", int(v))
		}

		return fmt.Sprintf("%c", int(v+'a'-10))
	})
}

func getOriginalName(unique string) string {
	//const reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
	uuidLength := 36

	if len(unique) >= uuidLength {
		tail := unique[len(unique)-uuidLength:]
		if reLiteralUUID.MatchString(tail) {
			return unique[0 : len(unique)-uuidLength-1]
		}
	}
	return unique
}

func compareObjects(objectA, objectB interface{}) bool {
	return isObject(objectA) && isObject(objectB)
}

func compareObjectKeys(itemAKeys, itemBKeys []string) bool {
	lengthA := len(itemAKeys)
	lengthB := len(itemBKeys)

	// nothing to compare, probably identical
	if lengthA == 0 && lengthB == 0 {
		return true
	}

	// duh
	if lengthA != lengthB {
		return false
	}

	mA := make(map[string]struct{}, lengthA)
	mB := make(map[string]struct{}, lengthB)
	for i := 0; i < lengthA; i++ {
		mA[itemAKeys[i]] = struct{}{}
	}
	for i := 0; i < lengthB; i++ {
		mB[itemAKeys[i]] = struct{}{}
	}
	for k := range mA {
		if _, ok := mB[k]; !ok {
			return false
		}
	}

	return true
}

func formatScopeKeys(keys []string) []string {
	dupKeys := append([]string{}, keys...)
	for i := range dupKeys {
		dupKeys[i] = format(dupKeys[i])
	}
	return dupKeys
}

func (t *parser) append(str string) {
	t.output += str
}

func (t *parser) indent(tabs int) {
	for i := 0; i < tabs; i++ {
		t.output += "\t"
	}
}

func (t *parser) indenter(tabs int) {
	for i := 0; i < tabs; i++ {
		t.stack[len(t.stack)-1] += "\t"
	}
}

func (t *parser) appender(str string) {
	t.stack[len(t.stack)-1] += str
}

// Sanitizes and formats a string to make an appropriate identifier in Go
func format(str string) string {
	if str == "" {
		return ""
	}

	if numReg.MatchString(str) {
		str = "Num" + str
	} else if str[0] <= '9' && str[0] >= '0' {
		numbers := map[byte]string{
			'0': "Zero_",
			'1': "One_",
			'2': "Two_",
			'3': "Three_",
			'4': "Four_",
			'5': "Five_",
			'6': "Six_",
			'7': "Seven_",
			'8': "Eight_",
			'9': "Nine_",
		}

		str = numbers[str[0]] + str[1:]
	}

	return formatReg.ReplaceAllString(toProperCase(str), "")
}

// Determines the most appropriate Go type
func goType(val interface{}) string {
	switch val.(type) {
	case string:
		if timeReg.MatchString(val.(string)) {
			return "time.Time"
		} else {
			return "string"
		}
	case bool:
		return "bool"
	case float64:
		s := fmt.Sprintf("%f", val)
		s = strings.TrimRight(s, "0")
		if s[len(s)-1] != '.' {
			return "float64"
		}

		intVal, _ := strconv.ParseInt(s[:len(s)-1], 10, 64)
		if intVal > -2147483648 && intVal < 2147483647 {
			return "int"
		} else {
			return "int64"
		}
	case map[string]interface{}:
		return "struct"
	case []interface{}:
		return "slice"
	default:
		return "interface{}"
	}
}

// Proper cases a string according to Go conventions
func toProperCase(str string) string {
	// https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.gogogo#L771-L810
	commonInitialisms := map[string]struct{}{
		"ACL":   {},
		"API":   {},
		"ASCII": {},
		"CPU":   {},
		"CSS":   {},
		"DNS":   {},
		"EOF":   {},
		"GUID":  {},
		"HTML":  {},
		"HTTP":  {},
		"HTTPS": {},
		"ID":    {},
		"IP":    {},
		"JSON":  {},
		"LHS":   {},
		"QPS":   {},
		"RAM":   {},
		"RHS":   {},
		"RPC":   {},
		"SLA":   {},
		"SMTP":  {},
		"SQL":   {},
		"SSH":   {},
		"TCP":   {},
		"TLS":   {},
		"TTL":   {},
		"UDP":   {},
		"UI":    {},
		"UID":   {},
		"UUID":  {},
		"URI":   {},
		"URL":   {},
		"UTF8":  {},
		"VM":    {},
		"XML":   {},
		"XMPP":  {},
		"XSRF":  {},
		"XSS":   {},
	}

	str = replaceAllStringSubmatchFunc(caseReg1, str, func(groups []string) string {
		sep := groups[1]
		frag := groups[2]

		upFrag := strings.ToUpper(frag)
		_, ok := commonInitialisms[upFrag]
		if ok {
			return sep + upFrag
		} else {
			return sep + string(upFrag[0]) + strings.ToLower(frag[1:])
		}
	})

	str = replaceAllStringSubmatchFunc(caseReg2, str, func(groups []string) string {
		sep := groups[1]
		frag := groups[2]

		upFrag := strings.ToUpper(frag)

		_, ok := commonInitialisms[sep+upFrag]
		if ok {
			return strings.ToUpper(sep + frag)
		} else {
			return sep + frag
		}
	})

	return str
}

func replaceAllStringSubmatchFunc(re *regexp.Regexp, str string, repl func([]string) string) string {
	result := ""
	lastIndex := 0

	for _, v := range re.FindAllSubmatchIndex([]byte(str), -1) {
		groups := []string{}
		for i := 0; i < len(v); i += 2 {
			groups = append(groups, str[v[i]:v[i+1]])
		}

		//result += repl(groups)
		result += str[lastIndex:v[0]] + repl(groups)
		lastIndex = v[1]
	}

	return result + str[lastIndex:]
}

func isObject(v interface{}) bool {
	_, ok := v.(map[string]interface{})
	return ok
}

func isArray(v interface{}) bool {
	_, ok := v.([]interface{})
	return ok
}

func (t *parser) parseScope(scope interface{}, depth int, flatten bool) {
	var sliceType string

	if !isObject(scope) && !isArray(scope) {
		if flatten && depth >= 2 {
			t.appender(goType(scope))
		} else {
			t.append(goType(scope))
		}
		return
	}

	if isArray(scope) {
		arr := toArray(scope)
		scopeLength := len(arr)

		for i := 0; i < scopeLength; i++ {
			thisType := goType(arr[i])
			if sliceType == "" {
				sliceType = thisType
			} else if sliceType != thisType {
				sliceType = mostSpecificPossibleGoType(thisType, sliceType)
				if sliceType == "interface{}" {
					break
				}
			}
		}

		slice := "[]"
		if flatten && (sliceType == "struct" || sliceType == "slice") {
			slice = fmt.Sprintf("[]%s", t.parent)
		}

		if flatten && depth >= 2 {
			t.appender(slice)
		} else {
			t.append(slice)
		}
		if sliceType == "struct" {
			allFields := make(map[string]field)

			// for each field counts how many times appears
			for i := 0; i < scopeLength; i++ {
				ss := arr[i] // Object.keys(scope[i])
				keys := getKeys(ss)
				sm := toMap(ss)
				for k := range keys {
					keyname := keys[k]
					ff := sm[keyname]
					if _, ok := allFields[keyname]; !ok {
						allFields[keyname] = field{
							value: ff,
							count: 0,
						}
					} else {
						existingValue := allFields[keyname].value
						currentValue := ff //scope[i][keyname]

						if compareObjects(existingValue, currentValue) {
							comparisonResult := compareObjectKeys(
								getKeys(&currentValue),
								getKeys(&existingValue),
							)
							if !comparisonResult {
								uv4 := uuidv4()
								keyname := fmt.Sprintf("%s_%s", keyname, uv4)
								allFields[keyname] = field{
									value: currentValue,
									count: 0,
								}
							}
						}
					}
					v, _ := allFields[keyname]
					allFields[keyname] = field{
						value: v.value,
						count: v.count + 1,
					}
				}
			}

			// create a common struct with all fields found in the current array
			// omitempty dict indicates if a field is optional
			var keys []string
			for k := range allFields {
				keys = append(keys, k)
			}

			scopes := make(map[string]interface{})
			omitempty := make(map[string]bool)
			for k := range keys {
				keyname := keys[k]
				elem := allFields[keyname]

				scopes[keyname] = elem.value
				omitempty[keyname] = elem.count != scopeLength
			}
			t.parseStruct(depth+1, t.innerTabs, scopes, omitempty, flatten) // finally parse the struct !!
		} else if sliceType == "slice" {
			t.parseScope(toArray(scope)[0], depth, flatten)
		} else {
			if flatten && depth >= 2 {
				if sliceType == "" {
					t.appender("interface{}")
				} else {
					t.appender(sliceType)
				}
			} else {
				if sliceType == "" {
					t.append("interface{}")
				} else {
					t.append(sliceType)
				}
			}
		}
	} else {
		if flatten {
			if depth >= 2 {
				t.appender(t.parent)
			} else {
				t.append(t.parent)
			}
		}

		t.parseStruct(depth+1, t.innerTabs, toMap(scope), nil, flatten)
	}
}

func getKeys(scope interface{}) []string {
	v := toMap(scope)
	if v == nil {
		return nil
	}

	var keys []string
	for k := range v {
		keys = append(keys, k)
	}
	return keys
}

func toMap(scope interface{}) map[string]interface{} {
	v, ok := scope.(map[string]interface{})
	if !ok {
		return nil
	}
	return v
}

func toArray(scope interface{}) []interface{} {
	v, ok := scope.([]interface{})
	if !ok {
		return nil
	}
	return v
}

func (t *parser) parseStruct(depth, innerTabs int, scope map[string]interface{}, omitempty map[string]bool, flatten bool) {
	if flatten {
		if depth >= 2 {
			t.stack = append(t.stack, "\n")
		} else {
			t.stack = append(t.stack, "")
		}
	}

	var someKeys []string
	for k := range scope {
		someKeys = append(someKeys, k)
	}

	if flatten && depth >= 2 {
		parentType := fmt.Sprintf("\ntype %s", t.parent)

		//const scopeKeys = formatScopeKeys(Object.keys(scope))
		scopeKeys := formatScopeKeys(someKeys)

		// this can only handle two duplicate items
		// future improvement will handle the case where there could
		// three or more duplicate keys with different values
		if _, ok := t.seen[t.parent]; ok {
			if compareObjectKeys(scopeKeys, t.seen[t.parent]) {
				t.stack = t.stack[:len(t.stack)-1]
				return
			}
		}
		t.seen[t.parent] = scopeKeys

		t.appender(fmt.Sprintf("%s struct {\n", parentType))
		innerTabs++
		for i := range someKeys {
			keyname := getOriginalName(someKeys[i])
			t.indenter(innerTabs)
			typename := format(keyname)
			t.appender(typename + " ")
			t.parent = typename
			t.parseScope(scope[someKeys[i]], depth, flatten)
			t.appender(" `json:\"" + keyname)
			if omitempty != nil && omitempty[someKeys[i]] {
				t.appender(",omitempty")
			}
			t.appender("\"`\n")
		}
		innerTabs--
		t.indenter(innerTabs)
		t.appender("}")
	} else {
		t.append("struct {\n")
		t.tabs++
		for i := range someKeys {
			keyname := getOriginalName(someKeys[i])
			t.indent(t.tabs)
			typename := format(keyname)
			t.append(typename + " ")
			t.parent = typename
			t.parseScope(scope[someKeys[i]], depth, flatten)
			t.append(" `json:\"" + keyname)
			if omitempty != nil && omitempty[someKeys[i]] {
				t.append(",omitempty")
			}
			t.append("\"`\n")
		}
		t.tabs--
		t.indent(t.tabs)
		t.append("}")
	}
	if flatten {
		t.accumulator += t.stack[len(t.stack)-1]
		t.stack = t.stack[:len(t.stack)-1]
	}
}
